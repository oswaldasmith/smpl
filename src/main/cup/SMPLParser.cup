package com.comp3652.smpl;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		SMPLLexer lexer;

		public SMPLParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};
scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println ("Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// Special Symbols
terminal PAIR, CAR, CDR, CONS, PAIR_PRED, LIST, SIZE, EQV_PRED, EQ_PRED,
         SUBSTR, DEF, PROC, CALL, LAZY, LET, IF, CASE
         PRINT, PRINTLN, READ, READINT, THEN, ELSE, LIST_CONCAT;

terminal LPAREN, RPAREN, COMMA, LBRACE, RBRACE, LBRACKET, RBRACKET SEMI;

terminal LINE_COMMENT, BLOCK_COMMENT;

// Arithmetic Operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN;


// Bitwise Operators
terminal BIT_AND, BIT_OR, BIT_NOT;


// Relational Operators
terminal EQ, GT, LT, LT_EQ, GT_EQ, NOT_EQ;


// Logical Operators
terminal LOGIC_AND, LOGIC_OR, LOGIC_NOT;


// terminals with values
terminal Integer DEC_INTEGER;
terminal String HEX_INTEGER;
terminal String BIN_INTEGER
terminal Double DOUBLE;
terminal String IDENT;
terminal String STRING;
terminal Character CHAR;
terminal Boolean TRUE;
terminal Boolean FALSE


/* Non terminals */
non terminal SMPLProgram smpl_program;
non terminal ExprSeq expr_seq;
non terminal Expr exp;
non terminal BinExpr bin_exp;           //Unused so far
non terminal ArithExpr arith_exp;
non terminal LogicExpr logic_exp;
non terminal RelationExpr relation_exp;
non terminal BitwiseExpr bitwise_exp;
non terminal AssignExpr assign_exp;
non terminal UnaryExpr un_exp;          //Unused so far
non terminal MinusExpr minus_exp;
non terminal PairDefExpr pair_def_exp;
non terminal CarExpr car_exp;
non terminal CdrExp cdr_exp;
non terminal VecDefExpr vector_def_exp;
non terminal VecAccessExpr vector_access_exp;
non terminal VecSizeExpr vector_size_exp;
non terminal ListDefExpr list_def_exp;
non terminal IfExpr if_exp;
non terminal FunDefExpr fun_def_exp;
non terminal FunCallExpr fun_call_exp;
non terminal ProcExpr proc_exp;
non terminal    <Header and Body>
non terminal PairPredExpr pair_pred_exp;
non terminal EquivPredExpr equiv_pred_exp;
non terminal EqualPredExpr equal_pred_exp;
non terminal SubstringExpr substring_exp;
non terminal CallExpr call_exp;
non terminal LazyDeclExpr lazy_decl_exp;
non terminal LetExpr let_exp;
non terminal DefineExpr define_exp;
non terminal NTupleExpr ntuple_exp
non terminal CompoundExpr compound_exp;
non terminal CaseExpr case_exp;
non terminal PrintExpr print_exp;
non terminal PrintLnExpr print_ln_exp;
non terminal ReadExpr read_exp;
non terminal ReadIntExpr read_int_exp;
non terminal ListConcatExpr list_concat_exp;
non terminal TermExpr term_exp;
non terminal FactorExpr factor_exp;
non terminal empty;


/* Grammar rules */

smpl_program        ::=  expr_seq:seq {: RESULT = new SMPLProgram(seq); :};

expr_seq            ::=  expr_seq:seq expr:e {: seq.add(e); RESULT = seq; :}
                        |expr:e {: RESULT = new ExprSeq(e); :};

expr                ::=  arith_exp
                        |logic_exp
                        |assign_exp
                        |bitwise_exp
                        |unary_exp
                        |minus_exp
                        |relation_exp
                        |pair_def_exp
                        |car_exp
                        |cdr_exp
                        |vector_def_exp
                        |vector_access_exp
                        |vector_size_exp
                        |list_def_exp
                        |if_exp
                        |fun_def_exp
                        |fun_call_exp
                        |proc_exp
                        |pair_pred_exp
                        |equiv_pred_exp
                        |equal_pred_exp
                        |substring_exp
                        |call_exp
                        |lazy_decl_exp
                        |let_exp
                        |compound_exp
                        |case_exp
                        |print_exp
                        |print_ln_exp
                        |read_exp
                        |read_int_exp
                        |list_concat_exp
                        ;


// Arithmetic Expressions:
arith_exp           ::=  arith_exp PLUS term_exp
                    ::= |arith_exp MINUS term_exp
                        |term_exp
                        ;

term_exp            ::=  term_exp MUL factor_exp
                        |term_exp DIV factor_exp
                        |term_exp MOD factor_exp
                        |factor_exp
                        ;

factor_exp          ::=  IDENT
                        |DEC_INTEGER
                        |DOUBLE
                        |LPAREN arith_exp RPAREN
                        |LPAREN
                        ;

// Logic Expressions:
logic_exp           ::=  logic_exp LOGIC_OR logic_exp
                        |logic_exp LOGIC_AND logic_exp
                        |logic_exp NOT logic_exp
                        |LPAREN logic_exp RPAREN
                        |TRUE
                        |FALSE
                        ;

// Relational Expressions:
relation_exp        ::=   arith_exp relation_op arith_exp

relation_op         ::=  EQ
                        |GT
                        |LT
                        |LT_EQ
                        |GT_EQ
                        |NOT_EQ
                        ;

// Bitwise Expressions:

bitwise_exp         ::=  arith_exp BIT_AND arith_exp
                        |arith_exp BIT_OR arith_exp
                        |arith_exp BIT_NOT arith_exp
                        ;

// Assignment Expressions:
assign_exp          ::=  IDENT ASSIGN arith_exp
                        |IDENT ASSIGN logic_exp
                        |IDENT ASSIGN relation_exp
                        |IDENT ASSIGN pair_def_exp
                        |IDENT ASSIGN car_exp
                        |IDENT ASSIGN cdr_exp
                        |IDENT ASSIGN vector_def_exp
                        |IDENT ASSIGN vector_access_exp
                        |IDENT ASSIGN list_def_exp
                        |IDENT ASSIGN fun_def_exp
                        |IDENT ASSIGN fun_call_exp
                        |IDENT ASSIGN proc_exp
                        |IDENT ASSIGN substr_exp
                        |IDENT ASSIGN call_exp
                        |IDENT ASSIGN let_exp
                        |IDENT ASSIGN list_concat_exp
                        ;

minus_exp           ::=  MINUS LPAREN arith_expr RPAREN;

pair_def_exp        ::=  PAIR LPAREN exp COMMA expr RPAREN ;# TODO Fix this shit -exp  type!

car_exp             ::=  CAR LPAREN IDENT RPAREN;

cdr_exp             ::=  CDR LPAREN IDENT RPAREN;

vec_def_exp         ::=  LBRACKET COLON LBRACKET vec_def_list RBRACKET COLON RBRACKET;

vec_def_list        ::=

vec_spec_exp

vec_access_exp      ::=  IDENT LBRACKET DEC_INTEGER  RBRACKET
                        |vec_def_exp LBRACKET DEC_INTEGER  RBRACKET
                        ;

vec_size_exp        ::=  SIZE LPAREN IDENT RPAREN
                        |SIZE LPAREN vec_def_exp RPAREN
                        ;


list_def_exp        ::=  LIST LPAREN LBRACKET ident_list RBRACKET RPAREN
                        |LIST LPAREN LBRACKET pair_def_list RBRACKET RPAREN
                        |LPAREN LBRACKET ident_list RBRACKET RPAREN
                        |LPAREN LBRACKET pair_def_exp RBRACKET RPAREN
                        ;

ident_list          ::=  ident_list COMMA IDENT
                         |IDENT
                         ;

if_exp              ::=   IF relation_exp THEN exp
                         |IF relation_exp THEN exp ELSE exp

cond_exp            ::=   # TODO May not be needed if relation_exp works instead

fun_def_exp         ::=   DEF IDENT proc_exp;

fun_call_exp        ::=   IDENT LPAREN param_list RPAREN

param_list          ::=   param_list COMMA param
                         |param
                         ;

param               ::=   IDENT
                         |arith_exp
                         |fun_call_exp
                         ;

proc_exp            ::=

equiv_pred_exp      ::=   EQV_PRED LPAREN  expr_list RPAREN;

equal_pred_exp      ::=   EQ_PRED LPAREN expr_list RPAREN;

substring_exp       ::=   SUBSTR LPAREN STRING COMMA DEC-INTEGER COMMA DEC-INTEGER


call_exp            ::=   CALL LPAREN IDENT COMMA list_def_exp;
                         |CALL LPAREN proc_exp COMMA list_def_exp;

proc_exp            ::=   PROC LPAREN ident_list RPAREN expr
                         |PROC LPAREN ident_list PERIOD ident_list
                         |PROC IDENT
                          ;

lazy_exp            ::=   LAZY LPAREN expr RPAREN

let_exp             ::=   LET LPAREN binding_list RPAREN expr_list


binding_list        ::=   IDENT EQ expr;


define_exp          ::=   DEF IDENT expr;


ntuple_exp          ::=   expr_list;

ntuple_assign_exp   ::=   ident_list ASSIGN ntuple_exp;

case_exp            ::=   CASE LBRACE predicate_list RBRACE;

predicate_list      ::=   predicate_list COMMA predicate
                         |predicate

predicate           ::   relation_exp COLON exp;

compound_exp        ::=   LBRACE expr_list RBRACE;

expr_list           ::=  expr_list COMMA expr
                          |expr

print_exp           ::=   PRINT expr;

print_ln_exp        ::=   LPAREN PRINTLN expr RPAREN  //possible omitted LPAREN in spec

comment             ::=   LINE_COMMENT
                         |BLOCK_COMMENT

empty               ::= ;
