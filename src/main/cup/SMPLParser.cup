package com.comp3652.smpl.lang;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};
scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println ("Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// special symbols
terminal VAR,DEF,LET,IF,CAR,CDR, PROC, LAZY, AND, OR, NOT,IFPAIR,PAIR,CALL,PRINT,PRINTLN,READ,READINT,CASE,SIZE,IFEQUIVALENT,IFEQUAL,LIST,SUBSTRING;
terminal LBRACKET,RBRACKET, LPAREN, RPAREN, COMMA, LBRACE, RBRACE, SEMI,COLON,THEN,ELSE;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN,TIMES;

//unary operators

// terminals with values
terminal Integer INTEGER;
terminal Double FLOAT;
terminal Double FRACTION;
terminal char CHAR;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal String CMP;
terminal String VARIABLE;
terminal String STRING;

/* Non terminals */
non terminal SMPLProgram program;
non terminal StmtSequence stmtList;
non terminal SMPLStatement stmt;
non terminal CarStmt car;
non terminal CdrStmt cdr;
non terminal IsPairStmt isPair;
non terminal PrintStmt print;
non terminal RetVctStmt retVec;
non terminal SizeStmt size;
non terminal IsEqualStmt isEqual;
non terminal IsEqvStmt isEqv;
non terminal SubStrStmt substr;
non terminal LazyStmt lazy;
non terminal ReadStmt read;
non terminal StmtDefinition definition;
non terminal StmtFnDefinition funDefn;
non terminal ExpFnCall funCall;
non terminal ArrayList<Exp> expList;
non terminal ExpProcedure proc;
non terminal ArrayList<String> idList;
non terminal ArrayList<String> idListE;
non terminal PairExp exPair;
non terminal VectorExp vector;
non terminal IfStmt if;
non terminal LetStmt let;
non terminal CaseStmt case;

non terminal ASTExp<AIRExp> arithExp;
non terminal ASTExp<AIRExp> arithTerm;
non terminal ASTExp<AIRExp> arithConstFactor;
non terminal ASTExp<AIRExp> arithFactor;


non terminal empty;
/* Grammar rules */

start with program;

program ::= stmtList:s {: RESULT = new SMPLProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
			lst.add(s);
			RESULT = lst;
		:} |
		stmt:s {:
			RESULT = new Sequence(s);
		:};

stmt ::= definition:d SEMI {: RESULT = d; :} |
	    arithExp:e SEMI {: RESULT = new SMPLStatement(e); :};

definition ::= VARIABLE:v ASSIGN arithExp:e {:
		   RESULT = new StmtDefinition(v, e);
		:} |
		funDefn:d {: RESULT = d; :} |
		proc:p {: RESULT = p; :} |
		if:i {: RESULT = i; :} |
		let:l {: RESULT = l; :} |
		lazy:l {: RESULT = l; :} |
		case:c {: RESULT = c; :} |
		funCall:f {: RESULT = f; :};

exPair ::= PAIR LPAREN arithExp:e1 COMMA arithExp:e2 RPAREN {:
            RESULT = new exPair(e1,e2);
        :};

car ::= CAR LPAREN exPair:p RPAREN {: RESULT = new CarStmt(p); :};

cdr ::= CDR LPAREN exPair:p RPAREN {: RESULT = new CdrStmt(p); :};

isPair ::= IFPAIR LPAREN exPair:p RPAREN {: RESULT = new IsPairStmt(p); :};

vector ::= LBRACKET COLON expList:l COLON RBRACKET {: RESULT = new VectorExp(lst); :};

retVec ::= vector:v LBRACKET INTEGER:i RBRACKET {: RESULT = new retVectStmt(v,i); :};

size ::= SIZE LPAREN vector:v RPAREN {: RESULT = new SizeStmt(v); :};

isEqual ::= IFEQUAL LPAREN arithExp:e COMMA arithExp:e2 RPAREN {: RESULT = new IsEqualStmt(e,e2); :};

isEqv ::= IFEQUIVALENT LPAREN arithExp:e COMMA arithExp:e2 RPAREN {: RESULT = new IsEqvStmt(e1,e2); :};

substr ::= SUBSTRING LPAREN STRING:s COMMA INTEGER:start COMMA INTEGER:end RPAREN {: RESULT = new SubStrStmt(s,start,end); :};

proc ::= PROC LPAREN idList:lst RPAREN stmtList:body {: RESULT = new ExpProcedure(lst,body); :};

print ::= PRINT LPAREN arithExp:e RPAREN {:
            RESULT = new PrintStmt(e);
          :} |
          PRINTLN LPAREN arithExp:e RPAREN {: RESULT = new PrintStmt(e); :};

read ::= READ LPAREN RPAREN {:
                RESULT = new ReadStmt();
         :} |
         READINT LPAREN RPAREN {:
                RESULT = new ReadStmt();
         :};

if ::=  IF arithExp:e THEN stmtList:body {:
            RESULT = new IfStmt(e,body);
        :} |
        IF arithExp:e THEN stmtList:body ELSE stmtList:other {:
            body.add(other);
            RESULT = new IfStmt(e,body);
        :};

case ::= CASE LBRACE expList:lst RBRACE arithExp:e1 COLON arithExp:e2 {: RESULT = new CaseStmt(lst,e1,e2); :};

let ::= LET RPAREN idList:ids LPAREN stmtList:body {: RESULT = new LetStmt(ids,e); :};

funDefn ::= DEF VARIABLE:name PROC LPAREN idListE:p RPAREN LBRACE stmtList:body RBRACE{:
	    	RESULT = new StmtFnDefinition(name,body,p); :};

funCall ::= VARIABLE:fn LPAREN expList:args RPAREN {:
	    	RESULT = new ExpFnCall(fn, args);
	    :} |
	    VARIABLE:fn LPAREN RPAREN {:
	    	RESULT = new ExpFnCall(fn, new ArrayList<Exp>());
	    :} |
	    CALL LPAREN VARIABLE:fn  COMMA expList:args RPAREN {:
	        RESULT = new ExpFnCall(fn, args);
        :} |
        car:c {:
            RESULT = c;
        :} |
        cdr:c {:
            RESULT = c;
        :} |
        isPair:p {:
            RESULT = p;
        :} |
        retVec:r {:
            RESULT = r;
        :} |
        size:s {:
            RESULT = s;
        :} |
        isEqual:e {:
            RESULT = e;
        :} |
        isEqv:e {:
            RESULT = e;
        :} |
        substr:s {:
            RESULT = s;
        :} |
        print:p {:
            RESULT = p;
        :} |
        read:r {:
            RESULT = r;
        :};

lazy ::= LAZY LPAREN arithExp:e RPAREN {: RESULT = new LazyStmt(e); :};

idList ::= idList:l COMMA VARIABLE:v {:
		    l.add(v);
		    RESULT = l;
       	   :} |
           VARIABLE:v {:
       	   	    ArrayList<String> lst = new ArrayList<String>();
		    lst.add(v);
		    RESULT = lst;
	   :};

idListE ::= idList:l {: RESULT = lst; :} |
            empty {: RESULT = new ArrayList<>();:};

expList ::= expList:lst COMMA arithExp:e {:
	        lst.add(e);
	    	RESULT = lst;
	    :}|
	    arithExp:e {:
	        ArrayList<Exp> lst = new ArrayList<Exp>();
		lst.add(e);
	    	RESULT = lst;
	    :} |
	    LIST LPAREN expList:lst RPAREN {:
	        RESULT = lst;
        :} |
        LBRACKET expList:lst RBRACKET {:
            RESULT = lst;
            :} |
		exPair:ep {:
		    RESULT = ep;
		    :} |
		vector:v {:
		    RESULT = v;
		    :};

arithExp ::= arithExp:e PLUS arithTerm:t {: RESULT = new ASTBinaryExp<AIRExp>("+", e, t); :} |
	     arithExp:e MINUS arithTerm:t {: RESULT = new ASTBinaryExp<AIRExp>("-", e, t); :} |
	     arithTerm:t {: RESULT = t; :};

arithTerm ::= arithTerm:t TIMES arithFactor:f {: RESULT = new ASTBinaryExp<AIRExp>("*", t, f); :}|
	      arithTerm:t DIV arithFactor:f {: RESULT = new ASTBinaryExp<AIRExp>("/", t, f); :}|
	      arithTerm:t MOD arithFactor:f {: RESULT = new ASTBinaryExp<AIRExp>("%", t, f); :}|
	      arithFactor:f {: RESULT = f; :};

arithConstFactor ::= INTEGER:ilit {: RESULT = new AIRExpInt(ilit); :} |
		     FRACTION:frac {: RESULT = new AIRExpFrac(frac); :} |
		     LPAREN arithExp:e RPAREN {: RESULT = e; :};

arithFactor ::= arithConstFactor:cf {: RESULT = cf; :} |
		VAR:var {: RESULT = new ASTVar(var); :} |
                MINUS arithFactor:f {:
		      RESULT = new ASTUnaryExp<AIRExp>("-", f);
		:};

empty ::= ;