package com.comp3652.smpl.lang;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};
scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println ("Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// special symbols
terminal DEF,LET, IN,IF, PROC, LAZY, AND, OR, NOT,PAIR,CALL,PRINT,PRINTLN,READ,READINT,CASE,SIZE,IFEQUIVALENT,IFEQUAL,LIST;
terminal LPAREN, RPAREN, COMMA, LBRACE, RBRACE, SEMI,COLON,THEN,ELSE;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN;

//unary operators

// terminals with values
terminal Integer INTEGER;
terminal Double FLOAT;
terminal char CHAR;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal String CMP;
terminal String VARIABLE;
terminal String STRING;

/* Non terminals */
non terminal Program program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;
non terminal PrintStmt print;
non terminal PrintStmt printLn;
non terminal ReadStmt read;
non terminal ReadStmt readInt;
non terminal StmtDefinition definition;
non terminal StmtFnDefinition funDefn;
non terminal ExpFnCall funCall;
non terminal ArrayList<Exp> expList;
non terminal ExpProcedure proc;
non terminal Exp letExpn;
non terminal ArrayList<StmtDefinition> defnList;
non terminal ArrayList<String> idList;
non terminal ArrayList<String> idListE;
non terminal Exp expression;
non terminal Exp term;
non terminal Exp factor;
non terminal PairExp exPair;
non terminal VectorExp vector;
non terminal IfStmt if;

non terminal empty;
/* Grammar rules */

start with program;

program ::= stmtList:s {: RESULT = new Program(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:};

stmt ::= definition:d SEMI {: RESULT = d; :} |
	    expression:e SEMI {: RESULT = new Statement(e); :};

definition ::= VARIABLE:v ASSIGN expression:e {:
		   RESULT = new StmtDefinition(v, e);
		:} |
		 funDefn:d {: RESULT = d; :} |
		 proc:p {: RESULT = p; :};

exPair ::= PAIR LPAREN expression:e1 COMMA expression:e2 RPAREN {:
            RESULT = new exPair(e1,e2);
        :};

proc ::= PROC LPAREN idList:lst RPAREN stmtList:body {: RESULT = new ExpProcedure(lst,body); :};


vector ::= LPAREN COLON expList:l COLON RPAREN {: RESULT = lst; :};

funDefn ::= DEF VARIABLE:name PROC LPAREN idListE:p RPAREN LBRACE stmtList:body RBRACE{:
	    	RESULT = new StmtFnDefinition(name,body,p); :};

funCall ::= VARIABLE:fn LPAREN expList:args RPAREN {:
	    	RESULT = new ExpFnCall(fn, args);
	    :} |
	    VARIABLE:fn LPAREN RPAREN {:
	    	RESULT = new ExpFnCall(fn, new ArrayList<Exp>());
	    :} |
	    CALL LPAREN VARIABLE:fn  COMMA expList:args RPAREN {:
	        RESULT = new ExpFnCall(fn, args);
        :};


idList ::= idList:l COMMA VARIABLE:v {:
		    l.add(v);
		    RESULT = l;
       	   :} |
           VARIABLE:v {:
       	   	    ArrayList<String> lst = new ArrayList<String>();
		    lst.add(v);
		    RESULT = lst;
	   :};

idListE ::= idList:l {: RESULT = lst; :} |
            empty {: RESULT = new ArrayList<>();:};

letExpn ::= LET defnList:dlst LBRACE stmtList:body RBRACE {:
	        RESULT = new ExpLet(dlst, body);
	    :};

defnList ::= definition:d COMMA defnList:lst {:
	     	lst.add(d);
		RESULT = lst;	         
	     :} |
	     definition:d {:
	        ArrayList<StmtDefinition> lst = new ArrayList<StmtDefinition>();
		lst.add(d);
		RESULT = lst;
	     :};

expList ::= expList:lst COMMA expression:e {:
	        lst.add(e);
	    	RESULT = lst;
	    :}|
	    expression:e {:
	        ArrayList<Exp> lst = new ArrayList<Exp>();
		lst.add(e);
	    	RESULT = lst;
	    :} |
	    LIST LPAREN expList:lst RPAREN {: RESULT = lst; :};

expression ::= 	expression:e PLUS term:t {:
			RESULT = new ExpAdd(e, t); :} |
		expression:e MINUS term:t {:
			RESULT = new ExpSub(e, t); :} |
		letExpn:lexp {: RESULT = lexp; :} |
		term:t {: RESULT = t; :} |
		exPair:ep {: RESULT = ep; :};

term ::= term:t MUL factor:f {:
		RESULT = new ExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ExpDiv(t, f); :} |
	 term:t MOD factor:f {:
		RESULT = new ExpMod(t, f); :} |
	 factor:f {: RESULT = f; :};

factor ::= INTEGER:ilit {: RESULT = new ExpLit(ilit); :} |
	   VARIABLE:var {: RESULT = new ExpVar(var); :} |
	   funCall:call {: RESULT = call; :} |
	   LPAREN expression:e RPAREN {: RESULT = e; :}	;

empty ::= ;
