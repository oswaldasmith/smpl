package com.comp3652.lang;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

parser code {: 
	SMPLLexer lexer;

	public SMPLParser(SMPLLexer l) {
	    // As of CUP v0.11, need to pass Lexer to superclass
	    super(l);
	    lexer = l;
	}

	public SMPLParser(String file) throws FileNotFoundException {
        this(new SMPLLexer(new FileReader(file)));
    }

    public SMPLParser(InputStream is) {
        this(new SMPLLexer(is));
    }

	public void report_error(String message, Object info) {
	    System.err.println(message);
	}

	public void syntax_error(Symbol cur_token) {
	    System.err.print("Line " + lexer.getLine() +
			     " near char " + lexer.getChar() + ": ");
	    report_error("Syntax error", cur_token);
	    System.err.println ("Last token read is " +
				 lexer.getText());
	}
:};

init with {: :};

scan with {:
	try {
		return lexer.next_token();
	} catch (java.io.IOException ioe) {
		System.out.println ("Unrecognised token");
		System.out.println(ioe.getMessage());
		throw ioe;
	}
:};

/* Terminals */

// special symbols
terminal LBRACKET,RBRACKET,LPAREN, RPAREN,COMMA, LBRACE, RBRACE, SEMI, COLON;

// functions
terminal DEF, PROC, LAZY;

// aithmetic
terminal PLUS, MINUS, DIV, MOD, TIMES;

//Builtin Statements
terminal PRINT, PRINTLN, READ, READINT, CASE;

//unary operators and Logic Extensions
terminal AND, OR, NOT;
terminal CMP, IF, THEN, ELSE, LET;

// terminals with values
terminal Integer INTEGER;
terminal Double FLOAT;
terminal Double FRACTION;
terminal Char CHAR;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal String VAR;
terminal String STRING;

/* Non terminals */

non terminal SMPLProgram program;
non terminal SMPLSequence stmtList;
non terminal SMPLStatement stmt;

non terminal SMPLAssign assign;
non terminal SMPLMulAssign mulAssign;

non terminal SMPLStatement funDef;
non terminal SMPLStatement condStmt;
non terminal SMPLStatement predExp;

non terminal SMPLFunCall funCall;

non terminal ASTExp<AIRExp> arithExp;
non terminal ASTExp<AIRExp> arithTerm;
non terminal ASTExp<AIRExp> arithConstFactor;
non terminal ASTExp<AIRExp> arithFactor;

non terminal ArrayList<ASTExp<AIRExp>> aExpList;   /* non-empty arith exp list */
non terminal ArrayList<ASTExp<AIRExp>> aExpListE;  /* potentially empty arith exp list */

// change this
// a function can be a parameter to another function
non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;

non terminal ArrayList<String> varList;
non terminal ArrayList<String> remainingVarList;

non terminal empty;

program ::= stmtList:s {: RESULT = new SMPLProgram(s); :};

stmtList ::= stmtList:seq stmt:s {:
				seq.addStatement(s);
				RESULT = seq;
			:} |
			empty {:
				RESULT = new SMPLSequence();
			:}

//stmt ::= expStmt:s {: RESULT = s; :} |
//		condStmt:s {: RESULT = s; :} |
//		caseStmt:s {: RESULT = s; :} |
//		defStmt:s {: RESULT = s; :} |
//		assign:s {: RESULT = s; :} |
//		mulAssign:s {: RESULT = s; :} |
//		arithExp:s {: RESULT = s; :} |
//		predExp:s {: RESULT = s; :} ;

stmt := expression:e {: RESULT = e; :} |
		case:c {: RESULT = c; :} |
		assign:a {: RESULT = a; :} |
		multipleAssign:m {: RESULT = m; :} |
		definition:d {: RESULT = d; :} ;

expression := expression:e AND:a conditionAnd:c {: RESULT = new CIRExp(e, c, c); :} |
			body:b {: RESULT = b; :} |
			conditionalAnd:c {: RESULT = c; :};

// not sure about this
// the body of the func can be a { stmts } or stmt
body := LBRACE stmtList:seq RBRACE {: RESULT = seq; :} |
		stmt:s {: RESULT = s; :};

case := CASE LBRACE caseStmts:seq RBRACE {: RESULT = new SMPLCaseStmt(seq); :};

caseStmts := caseStmts:seq COMMA caseExp:ce {: 
				seq.add(ce);
				RESULT = seq;
			:} |
			caseExp:ce {:
				ArrayList<SMPLStatement> lst = new ArrayList<>();
				lst.add(ce);
				RESULT = lst;
			:} |
			empty; // not sure if this breaks it, how do u return nothing?

assign ::= DEF VAR:v expression:e {: RESULT = new SMPLAssign(v, e); } |
			DEF VAR:v ASSIGN expression:e {: RESULT = new SMPLAssign(v, e); };

mulAssign := varList:lst ASSIGN expression:e {: RESULT = new SMPLMulAssign(lst, e); };

varList ::= VAR:v COMMA varList:lst {: 
			lst.add(0, v);
			RESULT = lst;
		:}

remainingVarList ::= remainingVarList:lst COMMA VAR:v {: 
			lst.add(v);
			RESULT = lst;
		:};

condStmt ::= IF predExp:cex THEN stmtList:cons {:
				RESULT = new SMPLCondStmt(cex, cons);
			:} |
			IF predExp:cex THEN stmtList:cons ELSE stmtList:alt {:
				RESULT = new SMPLCond(cex, cons, alt);
			:};


// not sure about this
// need to make it generic
predExp ::= predExp:pex CMP:cmp arithExp:exp


funDef ::= DEF VAR:v PROC LPAREN expressionListE:elist RPAREN stmtList:body


funCall ::= VAR:id LPAREN paramListE RPAREN {:
				
			:};

paramListE ::= paramList:lst {: RESULT = lst :} |
			empty {: RESULT = new ArrayList<>(); :};

paramList ::= paramList:lst COMMA VAR:id {:
				lst.add(id);
				RESULT = list;
			:} |
			VAR:id {:
				RESULT = new ArrayList<>();
				RESULT.add(id);
			:};

arithExp ::= arithExp:e PLUS arithTerm:t {: RESULT = new ASTBinaryExp<AIRExp>("+", e, t); :} |
	     arithExp:e MINUS arithTerm:t {: RESULT = new ASTBinaryExp<AIRExp>("-", e, t); :} |
	     arithTerm:t {: RESULT = t; :};

arithTerm ::= arithTerm:t TIMES arithFactor:f {: RESULT = new ASTBinaryExp<AIRExp>("*", t, f); :}|
	      arithTerm:t DIV arithFactor:f {: RESULT = new ASTBinaryExp<AIRExp>("/", t, f); :}|
	      arithTerm:t MOD arithFactor:f {: RESULT = new ASTBinaryExp<AIRExp>("%", t, f); :}|
	      arithFactor:f {: RESULT = f; :};


arithConstFactor ::= INTEGER:ilit {: RESULT = new AIRExpInt(ilit); :} |
		     FRACTION:frac {: RESULT = new AIRExpFrac(frac); :} |
		     LPAREN arithExp:e RPAREN {: RESULT = e; :};

arithFactor ::= arithConstFactor:cf {: RESULT = cf; :} |
				VAR:var {: RESULT = new ASTVar(var); :} |
                MINUS arithFactor:f {: RESULT = new ASTUnaryExp<AIRExp>("-", f); :};

empty ::= ;